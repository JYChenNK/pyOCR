#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 6.0.1
#  in conjunction with Tcl version 8.6
#    Apr 08, 2021 09:51:02 PM CST  platform: self.tops NT

import sys
import os
import time

import numpy as np
from PIL import Image
from PIL import ImageGrab
from PIL import ImageTk
import threading
# import serial
import struct
import socket

from pathlib import Path
# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage, Checkbutton, IntVar, END, Label

OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path("./assets")

def relative_to_assets(path: str) -> Path:
    print(ASSETS_PATH / Path(path))
    return ASSETS_PATH / Path(path)

# serialPort="COM5"   #串口
# baudRate=115200     #波特率
# ser=serial.Serial(serialPort,baudRate,timeout=0.5)


# local_port=('192.168.254.101',1001)
dSPACE_port = ('192.168.254.100',1000)
local_serve = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
# local_serve.bind(local_port)
local_serve.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 10)

last_string = ''

# 数字区域在电脑屏幕上的坐标
loc_timer = {'left_top_x': 60, 'left_top_y': 1180, 'right_buttom_x': 120, 'right_buttom_y': 1200}
loc_VO2 = {'left_top_x': 2125, 'left_top_y': 330, 'right_buttom_x': 2195, 'right_buttom_y': 360}
loc_VCO2 = {'left_top_x': 2215, 'left_top_y': 330, 'right_buttom_x': 2285, 'right_buttom_y': 360}
loc_VE = {'left_top_x': 2305, 'left_top_y': 330, 'right_buttom_x': 2375, 'right_buttom_y': 360}
loc_HR = {'left_top_x': 2305, 'left_top_y': 330, 'right_buttom_x': 2375, 'right_buttom_y': 360}

image_counter = 1

# 二值化阈值，自定义阈值为150, 小于150的是白色0 大于的是黑色1
threshold = 150
# 二值化对照表
bin_table = []
for i in range(256):
    if i < threshold:
        bin_table.append(0)
    else:
        bin_table.append(1)

# 字符Hash码
hash_vals = {
    "0": "10000011100000010001000100011000000110000011100000111000001110000011100000111000001110000011100000011000000100010000000110000011",
    "1": "00000000000000000010000011100000111000001110000011100000111000001110000011100000111000001110000011100000111000001110000011100000",
    "2": "00000001001000011111000011111000111110001111100011111000111100011111000111100011110001111100011110001111000111110000000000000000",
    "3": "00000011001000011111000111110001111100011110001110000111100000111110000111110001111110001111100011111000111100010110000100000011",
    "4": "11100011111000111100001111000011110100111101001110110011101100110011001100110011000000000000000011110011111100111111001111110011",
    "5": "10000000100000001001111110011111100111110001111100000011000000011111000011111000111110001111110011111000111110000010000100000001",
    "6": "11100001110000111000111110011111000111110001111100100011000000010001000100111000001110000011100000111000001110000001000110000001",
    "7": "00000000000000011111000111110001111100111111001111110011111001111110011111101111110011111100111111001111100011111000111100011111",
    "8": "10000001000000010001100000011000000110001000000110000011110000111000000100010000000110000011100000111000000110000001000010000001",
    "9": "10000001000000010001100000011000001110000011100000011000000110001000000010000000111110001111100111110001111100111100011110000111",
    ".": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000000",
}

def get_screenshot(var_num):
    global image_counter
    if var_num == 0:
        var_image = ImageGrab.grab(
            [loc_timer['left_top_x'], loc_timer['left_top_y'], loc_timer['right_buttom_x'], loc_timer['right_buttom_y']]) # 时间戳图像位置
    elif var_num == 1:
        var_image = ImageGrab.grab(
            [loc_VO2['left_top_x'], loc_VO2['left_top_y'], loc_VO2['right_buttom_x'], loc_VO2['right_buttom_y']])
    elif var_num == 2:
        var_image = ImageGrab.grab(
            [loc_VCO2['left_top_x'], loc_VCO2['left_top_y'], loc_VCO2['right_buttom_x'], loc_VCO2['right_buttom_y']])
    elif var_num == 3:
        var_image = ImageGrab.grab(
            [loc_VE['left_top_x'], loc_VE['left_top_y'], loc_VE['right_buttom_x'], loc_VE['right_buttom_y']])
    elif var_num == 4:
        var_image = ImageGrab.grab(
            [loc_HR['left_top_x'], loc_HR['left_top_y'], loc_HR['right_buttom_x'], loc_HR['right_buttom_y']])
    
    # var_image.save("./DataSet/" + str(image_counter) + ".jpg")
    # image_counter = image_counter + 1

    return var_image

def get_img(img):
    box_o2 = ([loc_VO2['left_top_x'], loc_VO2['left_top_y'], loc_VO2['right_buttom_x'], loc_VO2['right_buttom_y']])
    box_co2 = ([loc_VCO2['left_top_x'], loc_VCO2['left_top_y'], loc_VCO2['right_buttom_x'], loc_VCO2['right_buttom_y']])
    box_oe = ([loc_VE['left_top_x'], loc_VE['left_top_y'], loc_VE['right_buttom_x'], loc_VE['right_buttom_y']])
    # box_hr = ([loc_HR['left_top_x'], loc_HR['left_top_y'], loc_HR['right_buttom_x'], loc_HR['right_buttom_y']])
    image_vo2 = img.crop(box_o2)
    image_vco2 = img.crop(box_co2)
    image_ve = img.crop(box_oe)
    # image_hr = img.crop(box_hr)
    return image_vo2, image_vco2, image_ve #, image_hr

def binarize(img, threshold=threshold):
    """二值化"""
    # 图像的二值化，就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果。

    img = img.convert('L')  # 模式“L” 为灰色图像,它的每个像素用8个bit表示,0表示黑,255表示白,其他数字表示不同的灰度。
    # img.point 返回图像的副本，参数1：每个像素通过给定的bin_table表映射。该表应包含图像中每个波段的256个值。
    #                         参数2：仅当源图像的模式为“L”或“P”且输出的图像模式为“1”或源图像的模式为“I”且输出模式为“L”时，才可以使用此选项
    bin_img = img.point(bin_table, '1')
    return bin_img


def vertical_cut(img):
    """纵向切割"""
    global image_counter
    #  黑白反转
    px = list(np.sum(np.array(img) == 0, axis=0))  # 列 像素累加值
    py = list(np.sum(np.array(img) == 0, axis=1))  # 行 像素累加值
    interval = 9
    # 列表保存像素累加值大于0的列
    x0 = []
    for x in range(len(px)):
        if px[x] > 0:
            x0.append(x)
    y0 = []
    for y in range(len(py)):
        if py[y] > 1:
            y0.append(y)

    if len(x0) == 0:
        return []

    # 找出边界
    cut_list_x = [x0[0]+1]
    for i in range(1, len(x0)):
        if abs(x0[i] - x0[i - 1]) > 1:
            if (x0[i-1] - cut_list_x[-1]) > 1.5*interval :
                con_num = (x0[i-1] - cut_list_x[-1])//interval - 1
                con_interval = ((x0[i-1] - cut_list_x[-1])%interval)/con_num
                for j in range(con_num):
                    cut_list_x.extend([cut_list_x[-1] + interval*(j+1)+1 + int(con_interval*j), cut_list_x[-1] + interval*(j+1) + int(con_interval*(j+1))])
            cut_list_x.extend([x0[i-1]+1, x0[i]+1])
    if (x0[-1] - cut_list_x[-1]) > 1.5*interval:
        con_num = (x0[-1] - cut_list_x[-1])//interval - 1
        con_interval = ((x0[-1] - cut_list_x[-1])%interval)/con_num
        for j in range(con_num):
            cut_list_x.extend([cut_list_x[-1] + interval*(j+1) + int(con_interval*j), cut_list_x[-1] + interval*(j+1) + int(con_interval*(j+1))])
    cut_list_x.append(x0[-1]+1)

    cut_list_y = [y0[0]+1]
    cut_list_y.append(y0[-1])

    cut_imgs = []
    # 切割顺利的话应该是整对
    if len(cut_list_x) % 2 == 0:
        for i in range(len(cut_list_x) // 2):  # 每张图片的左右边界
            cut_img = img.crop([cut_list_x[i * 2], cut_list_y[0], cut_list_x[i * 2 + 1], cut_list_y[1]])
            cut_imgs.append(cut_img)
        return cut_imgs
    else:
        print('Vertical cut failed.')
        return []


def hashing(img):
    """计算哈希值"""
    # img.resize((width, height),Image.ANTIALIAS)  第二个参数：Image.NEAREST ：低质量 Image.BILINEAR：双线性 Image.BICUBIC ：三次样条插值 Image.ANTIALIAS：高质量
    img = img.resize((8, 16), Image.LANCZOS)
    px = np.array(img).flatten()  # flatten()把数组降到一维，默认是按行的方向降
    hash_val = (px).astype(int)
    hash_val = ''.join(str(e) for e in hash_val)  # 以''作为分隔符，将hash_val所有的元素合并成一个新的字符串，返回值：返回一个以分隔符''连接各个元素后生成的字符串
    return hash_val

def hashingTimer(img):
    """计算哈希值"""
    # img.resize((width, height),Image.ANTIALIAS)  第二个参数：Image.NEAREST ：低质量 Image.BILINEAR：双线性 Image.BICUBIC ：三次样条插值 Image.ANTIALIAS：高质量
    img = binarize(img)
    img = img.resize((30, 10), Image.LANCZOS)
    px = np.array(img).flatten()  # flatten()把数组降到一维，默认是按行的方向降
    hash_val = (px).astype(int)
    hash_val = ''.join(str(e) for e in hash_val)  # 以''作为分隔符，将hash_val所有的元素合并成一个新的字符串，返回值：返回一个以分隔符''连接各个元素后生成的字符串
    return hash_val

def hamming(hash1, hash2):
    """计算汉明距离"""
    if len(hash1) != len(hash2):
        print('hash1: ', hash1)
        print('hash2: ', hash2)
        raise ValueError("Undefined for sequences of unequal length")  # 异常
    # 返回hash1[i]!=hash2[i]的个数 两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。例如字符串“1111”与“1001”之间的汉明距离为2。
    return sum(i != j for i, j in zip(hash1, hash2))

def recognize(img):
    """识别部分"""
    if img:
        img = binarize(img)
        chars = vertical_cut(img)
        # print ('chars',chars)
        # 相近度列表
        nearness = {}
        expr = ''
        value = 0
        if chars:
            for char in chars:
                hash_val = hashing(char)
                # print ('hash_val',hash_val)
                for h in hash_vals:
                    nearness[h] = hamming(hash_val, hash_vals[h])
                expr += sorted(nearness.items(), key=lambda d: d[1])[0][0]
            return expr, float(expr)
        else:
            return '0', 0.0
    else:
        return '0', 0.0


def OCRloop():
    last_time_hashing = hashingTimer(get_screenshot(0))
    while 1:
        if ui.State == 1:
            this_time_hashing = hashingTimer(get_screenshot(0))
            hammingDis = hamming(this_time_hashing, last_time_hashing)

            if hammingDis > 2:

                last_time_hashing = this_time_hashing

                Image_VO2 = []
                Image_VCO2 = []
                Image_VE = []
                Image_HR = []

                if ui.VO2.get() == 1:
                    Image_VO2 = get_screenshot(1)
                    ui.IM_VO2 = ImageTk.PhotoImage(Image_VO2)
                    ui.img_vo2.configure(image = ui.IM_VO2)
                if ui.VCO2.get() == 1:
                    Image_VCO2 = get_screenshot(2)
                    ui.IM_VCO2 = ImageTk.PhotoImage(Image_VCO2)
                    ui.img_vco2.configure(image = ui.IM_VCO2)
                if ui.VE.get() == 1:
                    Image_VE = get_screenshot(3)
                    ui.IM_VE = ImageTk.PhotoImage(Image_VE)
                    ui.img_ve.configure(image = ui.IM_VE)
                # if ui.HR.get() == 1:
                #     Image_HR = get_screenshot(4)
                #     ui.IM_HR = ImageTk.PhotoImage(Image_HR)
                #     ui.img_hr.configure(image = ui.IM_HR)

                VO2_string,  VO2_value  = recognize(Image_VO2)
                VCO2_string, VCO2_value = recognize(Image_VCO2)
                VE_string,   VE_value   = recognize(Image_VE)
                # HR_string,   HR_value   = recognize(Image_HR)
                HR_string = '0'
                HR_value = 0.0

                res_string = ' '*6 + '  '*(5-len(VO2_string)) + VO2_string + ',' + ' '*17 + '  '*(5-len(VCO2_string)) + VCO2_string + ',' + ' '*17 + '  '*(5-len(VE_string)) + VE_string +  '\n'
                ui.Text.insert(END, res_string)
                ui.Text.see(END)
                ui.entry_vo2.configure(text = VO2_string)
                ui.entry_vco2.configure(text = VCO2_string)
                ui.entry_ve.configure(text = VE_string)

                # Data = [int(V02_value), int(VCO2_value), int(VE_value*10), int(HR_value),int((V02_value+VCO2_value+VE_value*10+HR_value)%256)]
                # buffer = struct.pack("hhhBB", *Data)
                # ser.write(buffer)
                # Data = [int(VO2_value), int(VCO2_value), int(VE_value*10), int(HR_value)]
                # buffer = struct.pack("!HHHH", *Data)
                # local_serve.sendto(buffer,dSPACE_port)
            else:
                time.sleep(0.1)

def setState():
    ui.State = 1


def resetState():
    ui.State = 0

def changeImg():
    ui.img_vo2.configure(img = ui.IM_VO2)


class pyCosmedGUI:
    def __init__(self):

        self.window = Tk()

        self.VO2 = IntVar()
        self.VCO2 = IntVar()
        self.VE = IntVar()
        self.HR = IntVar()
        self.State = 0

        self.IM_VO2 = []
        self.IM_VCO2 = []
        self.IM_VE = []
        self.IM_HR = []

        self.window.geometry("600x300")
        self.window.configure(bg = "#E8EAF6")
        self.window.title("pyCosmed - 102Lab RT-OCR Software")

        self.checkoff_image = PhotoImage(file=relative_to_assets("check_off.png"))
        self.checkon_image = PhotoImage(file=relative_to_assets("check_on.png"))
        self.entry_image = PhotoImage(file=relative_to_assets("entry.png"))
        self.checkgroup_image = PhotoImage(file=relative_to_assets("check_group.png"))
        self.buttonstart_image = PhotoImage(file=relative_to_assets("button_start.png"))
        self.buttonstop_image = PhotoImage(file=relative_to_assets("button_stop.png"))
        self.buttontest_image = PhotoImage(file=relative_to_assets("button_test.png"))
        self.entrytext_image = PhotoImage(file=relative_to_assets("entry_text.png"))
        self.img_image = PhotoImage(file=relative_to_assets("img.png"))

        self.canvas = Canvas(
            self.window,
            bg = "#E8EAF6",
            height = 300,
            width = 600,
            bd = 0,
            highlightthickness = 0,
            relief = "ridge"
        )
        self.canvas.place(x = 0, y = 0)

        ## 复选框
        self.check_bg = self.canvas.create_image(
            198.5,
            45.0,
            image=self.checkgroup_image
        )
        self.VECheck = Checkbutton(
            image=self.checkoff_image,
            selectimage=self.checkon_image,
            indicatoron=False,
            # command=lambda: print("button_ve clicked"),
            relief="flat",
            variable=self.VE
        )
        self.VECheck.place(
            x=230.0,
            y=35.0,
            width=20.0,
            height=20.0
        )

        self.canvas.create_text(
            258.0,
            35.0,
            anchor="nw",
            text="VE",
            fill="#111111",
            font=("Calibri", 16 * -1)
        )
        self.VCO2Check = Checkbutton(
            image=self.checkoff_image,
            selectimage=self.checkon_image,
            indicatoron=False,
            # command=lambda: print("button_vco2 clicked"),
            relief="flat",
            variable=self.VCO2
        )
        self.VCO2Check.place(
            x=128.0,
            y=35.0,
            width=20.0,
            height=20.0
        )

        self.canvas.create_text(
            156.0,
            35.0,
            anchor="nw",
            text="VCO2",
            fill="#111111",
            font=("Calibri", 16 * -1)
        )
        self.VO2Check = Checkbutton(
            image=self.checkoff_image,
            selectimage=self.checkon_image,
            indicatoron=False,
            # command=lambda: print("button_vo2 clicked"),
            relief="flat",
            variable=self.VO2
        )
        self.VO2Check.place(
            x=35.0,
            y=35.0,
            width=20.0,
            height=20.0
        )
        self.canvas.create_text(
            63.0,
            35.0,
            anchor="nw",
            text="VO2",
            fill="#111111",
            font=("Calibri", 16 * -1)
        )

        self.HRCheck = Checkbutton(
            image=self.checkoff_image,
            selectimage=self.checkon_image,
            indicatoron=False,
            # command=lambda: print("button_hr clicked"),
            relief="flat",
            variable=self.HR
        )
        self.HRCheck.place(
            x=311.0,
            y=35.0,
            width=20.0,
            height=20.0
        )
        self.canvas.create_text(
            339.0,
            35.0,
            anchor="nw",
            text="HR",
            fill="#111111",
            font=("Calibri", 16 * -1)
        )
        ### 文本框
        self.entry_bg = self.canvas.create_image(
            198.5,
            225.0,
            image=self.entry_image
        )
        self.Text = Text(
            bd=0,
            bg="#C5CAE9",
            highlightthickness=0,
            font="-family {Microsoft YaHei UI} -size 8 -weight bold"
        )
        self.Text.place(
            x=28.0,
            y=161.0,
            width=341.0,
            height=126.0
        )


        self.canvas.create_text(
            408.0,
            50.0,
            anchor="nw",
            text="Cosmed RT-OCR",
            fill="#064EE8",
            font=("Calibri", 24 * -1)
        )

        self.canvas.create_text(
            433.0,
            10.0,
            anchor="nw",
            text="102Lab",
            fill="#064EE8",
            font=("Calibri", 36 * -1)
        )

        
        self.StartButton = Button(
            image=self.buttonstart_image,
            borderwidth=0,
            highlightthickness=0,
            # command=lambda: print("button_5 clicked"),
            relief="flat",
            command = setState
        )
        self.StartButton.place(
            x=403.0,
            y=91.0,
            width=175.0,
            height=58.0
        )
        self.StopButton = Button(
            image=self.buttonstop_image,
            borderwidth=0,
            highlightthickness=0,
            # command=lambda: print("button_6 clicked"),
            relief="flat",
            command = resetState
        )
        self.StopButton.place(
            x=403.0,
            y=161.0,
            width=175.0,
            height=58.0
        )
        self.TestButton = Button(
            image=self.buttontest_image,
            borderwidth=0,
            highlightthickness=0,
            # command=lambda: print("button_7 clicked"),
            relief="flat"
        )
        self.TestButton.place(
            x=403.0,
            y=231.0,
            width=175.0,
            height=58.0
        )

        ## 图片区
        # self.img_vo2 = self.canvas.create_rectangle(
        #     31.0,
        #     90.0,
        #     101.0,
        #     120.0,
        #     fill="#FFFFFF",
        #     outline="")
        self.img_vo2 = Button(
            borderwidth=0,
            highlightthickness=0,
            image=self.img_image)
        self.img_vo2.place(
            x=30.0,
            y=100.0,
            width=70,
            height=30
        )
        self.img_vco2 = Button(
            borderwidth=0,
            highlightthickness=0,
            image=self.img_image)
        self.img_vco2.place(
            x=120.0,
            y=100.0,
            width=70,
            height=30
        )
        self.img_ve = Button(
            borderwidth=0,
            highlightthickness=0,
            image=self.img_image)
        self.img_ve.place(
            x=205.0,
            y=100.0,
            width=70,
            height=30
        )
        self.img_hr = Button(
            borderwidth=0,
            highlightthickness=0,
            image=self.img_image)
        self.img_hr.place(
            x=295.0,
            y=100.0,
            width=70,
            height=30
        )

        self.entry_vo2_bg = self.canvas.create_image(
            66.0,
            139.5,
            image=self.entrytext_image
        )
        self.entry_vo2 = Label(
            bd=0,
            bg="#E8EAF6",
            highlightthickness=0
        )
        self.entry_vo2.place(
            x=31.0,
            y=127.0,
            width=70.0,
            height=20.0
        )

        self.entry_vco2_bg = self.canvas.create_image(
            155.0,
            140.5,
            image=self.entrytext_image
        )
        self.entry_vco2 = Label(
            bd=0,
            bg="#E8EAF6",
            highlightthickness=0
        )
        self.entry_vco2.place(
            x=120.0,
            y=128.0,
            width=70.0,
            height=20.0
        )

        self.entry_ve_bg = self.canvas.create_image(
            240.0,
            139.5,
            image=self.entrytext_image
        )
        self.entry_ve = Label(
            bd=0,
            bg="#E8EAF6",
            highlightthickness=0
        )
        self.entry_ve.place(
            x=205.0,
            y=127.0,
            width=70.0,
            height=20.0
        )

        self.entry_hr_bg = self.canvas.create_image(
            329.0,
            139.5,
            image=self.entrytext_image
        )
        self.entry_hr = Label(
            bd=0,
            bg="#E8EAF6",
            highlightthickness=0
        )
        self.entry_hr.place(
            x=294.0,
            y=127.0,
            width=70.0,
            height=20.0
        )

if __name__ == '__main__':


    ui = pyCosmedGUI()
    ui.window.resizable(False, False)

    OCR_thread = threading.Thread(target=OCRloop)
    OCR_thread.setDaemon(True)
    OCR_thread.start()

    ui.window.mainloop()







