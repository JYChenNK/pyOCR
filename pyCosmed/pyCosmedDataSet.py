#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 6.0.1
#  in conjunction with Tcl version 8.6
#    Apr 08, 2021 09:51:02 PM CST  platform: self.tops NT

import sys
import os
import time

import numpy as np
from PIL import Image
from PIL import ImageGrab
import threading
# import serial
import struct
import socket

from pathlib import Path
# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage, Checkbutton, IntVar, END

OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path("./assets")

def relative_to_assets(path: str) -> Path:
    print(ASSETS_PATH / Path(path))
    return ASSETS_PATH / Path(path)

# serialPort="COM5"   #串口
# baudRate=115200     #波特率
# ser=serial.Serial(serialPort,baudRate,timeout=0.5)


# local_port=('192.168.254.101',1001)
dSPACE_port = ('192.168.254.100',1000)
local_serve = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
# local_serve.bind(local_port)
local_serve.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 10)

last_string = ''

# 数字区域在电脑屏幕上的坐标
loc_VO2 = {'left_top_x': 2125, 'left_top_y': 330, 'right_buttom_x': 2195, 'right_buttom_y': 360}
loc_VCO2 = {'left_top_x': 2215, 'left_top_y': 330, 'right_buttom_x': 2285, 'right_buttom_y': 360}
loc_VE = {'left_top_x': 2305, 'left_top_y': 330, 'right_buttom_x': 2375, 'right_buttom_y': 360}
loc_HR = {'left_top_x': 2305, 'left_top_y': 330, 'right_buttom_x': 2375, 'right_buttom_y': 360}

image_counter = 1
image_id = 0

# 二值化阈值，自定义阈值为150, 小于150的是白色0 大于的是黑色1
threshold = 150
# 二值化对照表
bin_table = []
for i in range(256):
    if i < threshold:
        bin_table.append(0)
    else:
        bin_table.append(1)

# 标准Hash码
hash_vals = {
    "0": "10000011100000010001000100011000000110000011100000111000001110000011100000111000001110000011100000011000000100010000000110000011",
    "1": "00000000000000000010000011100000111000001110000011100000111000001110000011100000111000001110000011100000111000001110000011100000",
    "2": "00000001001000011111000011111000111110001111100011111000111100011111000111100011110001111100011110001111000111110000000000000000",
    "3": "00000011001000011111000111110001111100011110001110000111100000111110000111110001111110001111100011111000111100010110000100000011",
    "4": "11100011111000111100001111000011110100111101001110110011101100110011001100110011000000000000000011110011111100111111001111110011",
    "5": "10000000100000001001111110011111100111110001111100000011000000011111000011111000111110001111110011111000111110000010000100000001",
    "6": "11100001110000111000111110011111000111110001111100100011000000010001000100111000001110000011100000111000001110000001000110000001",
    "7": "00000000000000011111000111110001111100111111001111110011111001111110011111101111110011111100111111001111100011111000111100011111",
    "8": "10000001000000010001100000011000000110001000000110000011110000111000000100010000000110000011100000111000000110000001000010000001",
    "9": "10000001000000010001100000011000001110000011100000011000000110001000000010000000111110001111100111110001111100111100011110000111",
    ".": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000000",
}

def get_screenshot(var_num):
    global image_counter
    if var_num == 1:
        var_image = ImageGrab.grab(
            [loc_VO2['left_top_x'], loc_VO2['left_top_y'], loc_VO2['right_buttom_x'], loc_VO2['right_buttom_y']])
    elif var_num == 2:
        var_image = ImageGrab.grab(
            [loc_VCO2['left_top_x'], loc_VCO2['left_top_y'], loc_VCO2['right_buttom_x'], loc_VCO2['right_buttom_y']])
    elif var_num == 3:
        var_image = ImageGrab.grab(
            [loc_VE['left_top_x'], loc_VE['left_top_y'], loc_VE['right_buttom_x'], loc_VE['right_buttom_y']])
    elif var_num == 4:
        var_image = ImageGrab.grab(
            [loc_HR['left_top_x'], loc_HR['left_top_y'], loc_HR['right_buttom_x'], loc_HR['right_buttom_y']])
    
    # var_image.save("./DataSet/" + str(image_counter) + ".jpg")
    # image_counter = image_counter + 1

    return var_image

def get_img(img):
    box_o2 = ([loc_VO2['left_top_x'], loc_VO2['left_top_y'], loc_VO2['right_buttom_x'], loc_VO2['right_buttom_y']])
    box_co2 = ([loc_VCO2['left_top_x'], loc_VCO2['left_top_y'], loc_VCO2['right_buttom_x'], loc_VCO2['right_buttom_y']])
    box_oe = ([loc_VE['left_top_x'], loc_VE['left_top_y'], loc_VE['right_buttom_x'], loc_VE['right_buttom_y']])
    # box_hr = ([loc_HR['left_top_x'], loc_HR['left_top_y'], loc_HR['right_buttom_x'], loc_HR['right_buttom_y']])
    image_vo2 = img.crop(box_o2)
    image_vco2 = img.crop(box_co2)
    image_ve = img.crop(box_oe)
    # image_hr = img.crop(box_hr)
    
    return image_vo2, image_vco2, image_ve #, image_hr

def binarize(img, threshold=threshold):
    """二值化"""
    # 图像的二值化，就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果。
    img = img.convert('L')  # 模式“L” 为灰色图像,它的每个像素用8个bit表示,0表示黑,255表示白,其他数字表示不同的灰度。
    # img.point 返回图像的副本，参数1：每个像素通过给定的bin_table表映射。该表应包含图像中每个波段的256个值。
    #                          参数2：仅当源图像的模式为“L”或“P”且输出的图像模式为“1”或源图像的模式为“I”且输出模式为“L”时，才可以使用此选项
    bin_img = img.point(bin_table, '1')
    return bin_img

def vertical_cut(img):
    """纵向切割"""
    global image_counter
    #  黑白反转
    px = list(np.sum(np.array(img) == 0, axis=0))  # 列 像素累加值
    py = list(np.sum(np.array(img) == 0, axis=1))  # 行 像素累加值
    interval = 9
    # 列表保存像素累加值大于0的列
    x0 = []
    for x in range(len(px)):
        if px[x] > 0:
            x0.append(x)
    y0 = []
    for y in range(len(py)):
        if py[y] > 1:
            y0.append(y)

    if len(x0) == 0:
        return []

    # 找出边界
    cut_list_x = [x0[0]+1]
    for i in range(1, len(x0)):
        if abs(x0[i] - x0[i - 1]) > 1:
            # if abs(x0[i-1] - cut_list_x[-1]) < 35:
            # print(x0[i-1] - cut_list_x[-1])
            if (x0[i-1] - cut_list_x[-1]) > 1.5*interval :
                # print('Connected: ' + str(image_id))
                con_num = (x0[i-1] - cut_list_x[-1])//interval - 1
                con_interval = ((x0[i-1] - cut_list_x[-1])%interval)/con_num
                for j in range(con_num):
                    cut_list_x.extend([cut_list_x[-1] + interval*(j+1)+1 + int(con_interval*j), cut_list_x[-1] + interval*(j+1) + int(con_interval*(j+1))])
            cut_list_x.extend([x0[i-1]+1, x0[i]+1])
    if (x0[-1] - cut_list_x[-1]) > 1.5*interval :
        # print('Connected: ' + str(image_id))
        con_num = (x0[-1] - cut_list_x[-1])//interval - 1
        con_interval = ((x0[-1] - cut_list_x[-1])%interval)/con_num
        for j in range(con_num):
            cut_list_x.extend([cut_list_x[-1] + interval*(j+1) + int(con_interval*j), cut_list_x[-1] + interval*(j+1) + int(con_interval*(j+1))])
    cut_list_x.append(x0[-1]+1)
    # print("cut_list_x: " + str(cut_list_x))

    cut_list_y = [y0[0]+1]
    cut_list_y.append(y0[-1])

    # print('cut_list_y',cut_list_y)

    cut_imgs = []
    # 切割顺利的话应该是整对
    if len(cut_list_x) % 2 == 0:
        for i in range(len(cut_list_x) // 2):  # 每张图片的左右边界
            cut_img = img.crop([cut_list_x[i * 2], cut_list_y[0], cut_list_x[i * 2 + 1], cut_list_y[1]])
            cut_imgs.append(cut_img)
        return cut_imgs
    else:
        print('Vertical cut failed.')
        return []

def hashing(img):
    """计算哈希值"""
    # img.resize((width, height),Image.ANTIALIAS)  第二个参数：Image.NEAREST ：低质量 Image.BILINEAR：双线性 Image.BICUBIC ：三次样条插值 Image.ANTIALIAS：高质量
    img = img.resize((8, 16), Image.LANCZOS)
    px = np.array(img).flatten()  # flatten()把数组降到一维，默认是按行的方向降
    hash_val = (px).astype(int)
    hash_val = ''.join(str(e) for e in hash_val)  # 以''作为分隔符，将hash_val所有的元素合并成一个新的字符串，返回值：返回一个以分隔符''连接各个元素后生成的字符串
    return hash_val

def hamming(hash1, hash2):
    """计算汉明距离"""
    if len(hash1) != len(hash2):
        print('hash1: ', hash1)
        print('hash2: ', hash2)
        raise ValueError("Undefined for sequences of unequal length")  # 异常
    # 返回hash1[i]!=hash2[i]的个数 两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。例如字符串“1111”与“1001”之间的汉明距离为2。
    return sum(i != j for i, j in zip(hash1, hash2))


def recognize(img):
    """识别部分"""
    if img:
        img = binarize(img)
        chars = vertical_cut(img)
        # print ('chars',chars)
        # 相近度列表

        nearness = {}
        expr = ''
        if chars:
            for char in chars:
                hash_val = hashing(char)
                for h in hash_vals:
                    nearness[h] = hamming(hash_val, hash_vals[h])
                expr += sorted(nearness.items(), key=lambda d: d[1])[0][0]
            return expr, float(expr)
        else:
            return '0', 0.0
    else:
        return '0', 0.0


def OCRloop():
    # 
    # for i in range(1,500):
    #     image_id = i
    #     img = Image.open("./DataSet/" + str(i) + ".jpg")
    #     recognize(img)

    # for i in range(11):
    #     img = Image.open("./DataSetChar/" + str(i) + ".jpg")
    #     img = binarize(img)
    #     hash_val = hashing(img)
    #     print(hash_val)

    # for i in range(16):
    #     img = Image.open("./DataSetChar/" + str(i) + ".jpg")
    #     VO2_string = recognize(img)
    #     print(VO2_string)

    for i in range(500):
        img = Image.open("./DataSet/" + str(i+1) + ".jpg")
        data_string, data = recognize(img)
        print(data)
        img.save("./DataSetValid/" + data_string + ".jpg")


if __name__ == '__main__':

    OCRloop()

    # ui = pyCosmedGUI()
    # ui.window.resizable(False, False)

    # OCR_thread = threading.Thread(target=OCRloop)
    # OCR_thread.setDaemon(True)
    # OCR_thread.start()

    # ui.window.mainloop()







